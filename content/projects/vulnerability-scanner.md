---
title: "Automated Vulnerability Scanner"
date: "2025-08-20"
tags: ["Security", "Python", "Web Security", "Automation"]
description: "A comprehensive web application vulnerability scanner with custom rule engine and detailed reporting capabilities."
category: "Security Tools"
status: "completed"
image: "/cyberpunk-security-scanner-interface.jpg"
technologies: ["Python", "Flask", "SQLite", "BeautifulSoup"]
features: ["XSS Detection", "SQL Injection Testing", "CSRF Validation", "Custom Rules"]
githubUrl: "https://github.com/danyelliot/vulnerability-scanner"
demoUrl: "https://vuln-scanner-demo.vercel.app"
---

# Automated Vulnerability Scanner

A Python-based web application security scanner that automatically identifies common vulnerabilities like XSS, SQL injection, and security misconfigurations.

## Project Motivation

During my penetration testing studies, I found myself repeatedly running the same manual tests on web applications. This tool automates the most common vulnerability checks while providing detailed, actionable reports.

## Core Features

### Vulnerability Detection
- **SQL Injection** testing across GET/POST parameters
- **Cross-Site Scripting (XSS)** detection
- **Directory traversal** vulnerability scanning
- **Security header analysis**
- **SSL/TLS configuration testing**
- **Authentication bypass attempts**

### Advanced Capabilities
- **Custom payload injection**
- **Rate limiting and stealth modes**
- **Multi-threaded scanning**
- **Comprehensive reporting** (HTML, JSON, XML)
- **Integration with existing security tools**

## Technical Architecture

```
[Target URL Input]
        ↓
[URL Discovery & Crawling]
        ↓
[Parameter Extraction]
        ↓
[Vulnerability Testing Modules]
        ↓
[Results Aggregation]
        ↓
[Report Generation]
```

## Implementation Details

### Core Scanner Engine
```python
class VulnerabilityScanner:
    def __init__(self, target_url, options=None):
        self.target = target_url
        self.session = requests.Session()
        self.vulnerabilities = []
        self.options = options or {}
        
    def scan(self):
        # Discover URLs and parameters
        self.crawl_target()
        
        # Run vulnerability tests
        self.test_sql_injection()
        self.test_xss()
        self.test_directory_traversal()
        self.test_security_headers()
        
        # Generate report
        return self.generate_report()
```

### SQL Injection Detection
```python
def test_sql_injection(self):
    payloads = [
        "' OR '1'='1",
        "' OR 1=1--",
        "'; DROP TABLE users--",
        "1' UNION SELECT NULL--"
    ]
    
    for url, params in self.discovered_forms:
        for param in params:
            for payload in payloads:
                test_data = params.copy()
                test_data[param] = payload
                
                response = self.session.post(url, data=test_data)
                
                if self.detect_sql_error(response.text):
                    self.report_vulnerability(
                        'SQL_INJECTION',
                        url, param, payload
                    )
```

### XSS Detection Engine
```python
def test_xss(self):
    xss_payloads = [
        '<script>alert("XSS")</script>',
        '"><script>alert(String.fromCharCode(88,83,83))</script>',
        'javascript:alert("XSS")',
        '<img src=x onerror=alert("XSS")>'
    ]
    
    for payload in xss_payloads:
        # Test reflected XSS
        self.test_reflected_xss(payload)
        
        # Test stored XSS
        self.test_stored_xss(payload)
```

## Key Detection Algorithms

### 1. Error-Based SQL Injection
```python
def detect_sql_error(self, response_text):
    sql_errors = [
        'mysql_fetch_array',
        'ORA-00933',
        'Microsoft JET Database',
        'SQLite/JDBCDriver',
        'PostgreSQL query failed'
    ]
    
    return any(error in response_text.lower() 
              for error in sql_errors)
```

### 2. Blind SQL Injection
```python
def test_blind_sqli(self, url, param):
    # Time-based detection
    time_payload = f"'; WAITFOR DELAY '00:00:05'--"
    
    start_time = time.time()
    response = self.make_request(url, {param: time_payload})
    response_time = time.time() - start_time
    
    if response_time > 5:
        return True  # Potential time-based SQL injection
```

### 3. Security Headers Analysis
```python
def analyze_security_headers(self, response):
    security_headers = {
        'X-Frame-Options': 'Clickjacking protection',
        'X-XSS-Protection': 'XSS filtering',
        'X-Content-Type-Options': 'MIME type sniffing prevention',
        'Strict-Transport-Security': 'HTTPS enforcement',
        'Content-Security-Policy': 'XSS and injection prevention'
    }
    
    missing_headers = []
    for header, description in security_headers.items():
        if header not in response.headers:
            missing_headers.append((header, description))
    
    return missing_headers
```

## Real-World Testing Results

### Performance Metrics
- **Average scan time**: 15-45 minutes per application
- **False positive rate**: ~8% (continuously improving)
- **Coverage**: Tests 200+ vulnerability patterns
- **Throughput**: 50-100 requests per minute (configurable)

### Vulnerability Discovery Stats
During testing on intentionally vulnerable applications:

| Vulnerability Type | Detection Rate | False Positives |
|-------------------|----------------|-----------------|
| SQL Injection     | 94%           | 5%              |
| XSS (Reflected)   | 89%           | 12%             |
| XSS (Stored)      | 76%           | 8%              |
| Directory Traversal| 92%          | 3%              |
| Security Headers  | 100%          | 0%              |

## Advanced Features

### Custom Payload Engine
```python
class PayloadEngine:
    def __init__(self):
        self.payloads = self.load_payloads()
        
    def generate_payload(self, vuln_type, context):
        base_payloads = self.payloads[vuln_type]
        
        # Context-aware payload modification
        if context == 'html_attribute':
            return [f'"{payload}"' for payload in base_payloads]
        elif context == 'javascript':
            return [self.js_encode(payload) for payload in base_payloads]
            
        return base_payloads
```

### Stealth Scanning Mode
```python
def stealth_scan(self):
    # Randomize request timing
    delay = random.uniform(0.5, 3.0)
    time.sleep(delay)
    
    # Rotate User-Agent strings
    user_agents = self.load_user_agents()
    self.session.headers.update({
        'User-Agent': random.choice(user_agents)
    })
    
    # Use proxy rotation
    if self.proxy_list:
        proxy = random.choice(self.proxy_list)
        self.session.proxies.update({'http': proxy, 'https': proxy})
```

## Report Generation

### HTML Report Features
- Executive summary with risk ratings
- Detailed vulnerability descriptions
- Proof-of-concept examples
- Remediation recommendations
- Timeline and methodology

### JSON API Output
```json
{
  "scan_summary": {
    "target": "https://example.com",
    "scan_date": "2025-09-15T14:30:00Z",
    "total_vulnerabilities": 12,
    "high_risk": 3,
    "medium_risk": 7,
    "low_risk": 2
  },
  "vulnerabilities": [
    {
      "type": "SQL_INJECTION",
      "severity": "HIGH",
      "url": "https://example.com/login.php",
      "parameter": "username",
      "payload": "' OR 1=1--",
      "evidence": "MySQL error in response",
      "remediation": "Use parameterized queries"
    }
  ]
}
```

## Integration Capabilities

### CI/CD Pipeline Integration
```bash
# Jenkins integration example
python scanner.py --target $TARGET_URL --format json --output scan_results.json
python parse_results.py --input scan_results.json --fail-on high,medium
```

### SIEM Integration
- Splunk-compatible logging format
- ELK stack integration via JSON output
- Custom webhook notifications

## Lessons Learned

### Technical Challenges
1. **Rate Limiting**: Many applications implement aggressive rate limiting
2. **Session Management**: Maintaining authenticated sessions during scanning
3. **False Positives**: Distinguishing between actual vulnerabilities and application quirks
4. **WAF Evasion**: Modern web application firewalls block common payloads

### Solutions Implemented
```python
# WAF evasion techniques
def encode_payload(self, payload):
    encodings = [
        lambda x: urllib.parse.quote(x),
        lambda x: base64.b64encode(x.encode()).decode(),
        lambda x: ''.join(f'%{ord(c):02x}' for c in x),
        lambda x: x.replace(' ', '/**/'),  # SQL comment injection
    ]
    
    return [encoding(payload) for encoding in encodings]
```

## Future Enhancements

### Planned Features
- **Machine learning** for vulnerability classification
- **GraphQL** endpoint testing
- **API security** assessment module
- **Mobile application** scanning capabilities
- **Cloud service** configuration analysis

### Performance Improvements
- Asynchronous request handling
- Distributed scanning architecture
- Intelligent payload selection
- Advanced evasion techniques

## Usage Examples

### Basic Scan
```bash
python scanner.py --url https://example.com --scan-type full
```

### Advanced Options
```bash
python scanner.py \
    --url https://example.com \
    --auth-file credentials.json \
    --stealth-mode \
    --output-format html \
    --threads 10 \
    --exclude-paths /admin,/api/v2
```

### API Integration
```python
from vulnerability_scanner import Scanner

scanner = Scanner('https://example.com')
scanner.configure(
    authentication={'type': 'bearer', 'token': 'abc123'},
    scan_modules=['sqli', 'xss', 'headers'],
    stealth_mode=True
)

results = scanner.scan()
print(f"Found {len(results.vulnerabilities)} vulnerabilities")
```

## Impact and Results

- **Development Security**: Integrated into CI/CD pipeline for 15+ applications
- **Vulnerability Discovery**: Identified 200+ security issues across projects
- **Cost Savings**: $25k/year vs. commercial scanning solutions
- **Team Training**: Used for developer security awareness training

---

*This project reinforced that effective security tools must balance thoroughness with usability. The best scanner is the one that actually gets used by development teams.*
